#!/usr/bin/env bash

# Git shortcuts

# This file cannot be named .git, because most editors will hide it then.
# TODO Consider to move the Git aliases from .gitconfig to this file to have everything at one place.
# TODO Remove aliases that are already part of the Oh My Zsh plugin.

alias gb='git branch'
alias gba='git branch --all'
alias gbr='git branch --remote'
alias gco='git checkout'
alias gcd='git checkout develop && glc'
alias gcm='git checkout master && glc'
alias gcs='git checkout release/staging && glc'
alias gdt='git describe --tags $(git rev-list --tags --max-count=1)'
alias gd='git diff'
alias gf='git fetch'
alias gl='git pull'
alias glc='git pull origin "$(git_current_branch)"'
alias gld='git pull origin develop'
alias gp='git push'
alias gpc='git push origin "$(git_current_branch)"'
alias gr='git remote -v'
alias gst='git status'
alias gspc='git stash push -m "$(git_current_branch)"'

alias gfco='git_fetch_checkout'
git_fetch_checkout() {
  gf && gco "$1" && glc
}

alias gtl='git_tag_list'
git_tag_list() {
  git tag --sort=-version:refname | head -n "${1:-5}"
}

# Clean up local branches that do not exist on remote anymore (https://stackoverflow.com/a/17029936)
alias gclb='git-clean-local-branches'

git_clean_local_branches() {
  local force=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--force)
        force=true
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  # Fetch and prune remote branches
  git fetch --prune

  # Get list of branches to delete
  local branches_to_delete
  branches_to_delete=$(git branch -r | awk "{print \$1}" | grep -E -v -f /dev/fd/0 <(git branch -vv | grep origin) | awk "{print \$1}")

  if [[ -z "$branches_to_delete" ]]; then
    echo "No branches to delete"
    return 0
  fi

  # Delete branches based on force flag
  if [[ "$force" = true ]]; then
    echo "$branches_to_delete" | xargs git branch -D
  else
    echo "$branches_to_delete" | xargs git branch -d
  fi
}

# Helper function to create a new branch
_create_branch() {
  local prefix=""
  local default_base=""

  # Check if we're calling the function directly with a prefix
  # or if we're calling it from the wrapper functions (hf, bf, fe)
  if [[ $# -ge 2 ]] && [[ "$1" != "-"* ]] && [[ "$2" != "-"* ]]; then
    # Called with explicit prefix and base
    prefix="$1"
    default_base="$2"
    shift 2
  elif [[ $# -ge 1 ]] && [[ "$1" != "-"* ]]; then
    # Check if first argument is a valid prefix or branch description
    if [[ "$1" == "hotfix" ]] || [[ "$1" == "bugfix" ]] || [[ "$1" == "feature" ]]; then
      prefix="$1"
      default_base="develop"
      shift 1
    else
      # First argument is branch description, no prefix
      default_base="develop"
    fi
  else
    # No arguments or first argument is an option
    default_base="develop"
  fi

  # Show help if no arguments or help flag
  if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    if [[ -n "$prefix" ]] && [[ "$prefix" != "-"* ]]; then
      echo "Usage: ${prefix} [options] <branch-description>"
      echo
      echo "Create a new ${prefix} branch from a specified base branch."
    else
      echo "Usage: _create_branch [prefix] [default-base] [options] <branch-description>"
      echo
      echo "Create a new branch from a specified base branch."
    fi
    echo
    echo "Options:"
    echo "  -h, --help         Show this help message"
    echo "  -b, --base <ref>   Use <ref> as base branch instead of ${default_base}"
    echo
    if [[ -n "$prefix" ]] && [[ "$prefix" != "-"* ]]; then
      echo "Examples:"
      echo "  ${prefix} fix critical bug     # Creates ${prefix}/fix-critical-bug from ${default_base}"
      echo "  ${prefix} test-456 add feature # Creates ${prefix}/TEST-456-add-feature from ${default_base}"
      echo "  ${prefix} -b main new thing    # Creates ${prefix}/new-thing from main"
    else
      echo "Examples:"
      echo "  _create_branch feature develop fix critical bug  # Creates feature/fix-critical-bug from develop"
      echo "  _create_branch fix critical bug                  # Creates fix-critical-bug from develop"
      echo "  _create_branch check-123 fix bug                 # Creates CHECK-123-fix-bug from develop"
      echo "  _create_branch test-456 add feature              # Creates TEST-456-add-feature from develop"
      echo "  _create_branch feature -b main new thing         # Creates feature/new-thing from main"
    fi
    return 0
  fi

  local base_branch="$default_base"
  local args=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--base)
        base_branch="$2"
        shift 2
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  # Check if we have a branch description
  if [[ ${#args[@]} -eq 0 ]]; then
    echo "Error: No branch description provided"
    if [[ -n "$prefix" ]] && [[ "$prefix" != "-"* ]]; then
      echo "Try '${prefix} --help' for usage information"
    else
      echo "Try '_create_branch --help' for usage information"
    fi
    return 1
  fi

  # Join remaining arguments with hyphens
  local branch_suffix="$(printf "%s" "${args[*]}" | tr ' ' '-')"

  # Check if branch_suffix starts with an issue number pattern (single word followed by hyphen and digits)
  if [[ "$branch_suffix" =~ ^([a-zA-Z]+)-([0-9]+)-(.*)$ ]]; then
    # Extract issue prefix, issue number, and remaining description
    local issue_prefix="${BASH_REMATCH[1]}"
    local issue_number="${BASH_REMATCH[2]}"
    local description="${BASH_REMATCH[3]}"

    # Make issue prefix uppercase and convert description to lowercase
    issue_prefix=$(echo "$issue_prefix" | tr '[:lower:]' '[:upper:]')
    description=$(echo "$description" | tr '[:upper:]' '[:lower:]')

    # Reconstruct branch_suffix with uppercase issue prefix and lowercase description
    if [[ -n "$description" ]]; then
      branch_suffix="${issue_prefix}-${issue_number}-${description}"
    else
      branch_suffix="${issue_prefix}-${issue_number}"
    fi
  elif [[ "$branch_suffix" =~ ^([a-zA-Z]+)-([0-9]+)$ ]]; then
    # Handle case where there's only issue number without description
    local issue_prefix="${BASH_REMATCH[1]}"
    local issue_number="${BASH_REMATCH[2]}"

    # Make issue prefix uppercase
    issue_prefix=$(echo "$issue_prefix" | tr '[:lower:]' '[:upper:]')
    branch_suffix="${issue_prefix}-${issue_number}"
  fi

  # Create branch name with or without prefix
  local branch_name
  if [[ -n "$prefix" ]] && [[ "$prefix" != "-"* ]]; then
    branch_name="$prefix/$branch_suffix"
  else
    branch_name="$branch_suffix"
  fi

  git checkout -b "$branch_name" "origin/$base_branch" && git push -u origin "$branch_name"
}

# Create a branch without a prefix
create_branch() {
  _create_branch "" "develop" "$@"
}

# Create a hotfix branch (default base: master)
hf() {
  _create_branch "hotfix" "master" "$@"
}

# Create a bugfix branch (default base: develop)
bf() {
  _create_branch "bugfix" "develop" "$@"
}

# Create a feature branch (default base: develop)
fe() {
  _create_branch "feature" "develop" "$@"
}

